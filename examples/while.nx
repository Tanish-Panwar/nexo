main.rs:
mod token;
mod lexer;
mod ast;
mod parser;
mod semantic;
mod interpreter;

use lexer::Lexer;
use parser::Parser;
use semantic::SemanticAnalyzer;
use interpreter::Interpreter;
use token::Token;

use std::env;
use std::fs;

fn main() {
    let filename = &env::args().collect::<Vec<_>>()[1];
    let source = fs::read_to_string(filename).unwrap();

    let mut lexer = Lexer::new(&source);
    let mut tokens = Vec::new();
    loop {
        let t = lexer.next_token();
        tokens.push(t.clone());
        if t == Token::EOF {
            break;
        }
    }

    let mut parser = Parser::new(tokens);
    let ast = parser.parse_program();

    let mut semantic = SemanticAnalyzer::new();
    semantic.analyze(&ast);

    let mut interpreter = Interpreter::new(&ast);
    interpreter.run();
}


ast.rs:
#[derive(Debug, Clone)]
pub struct Program {
    pub functions: Vec<FunctionDecl>,
}

#[derive(Debug, Clone)]
pub struct FunctionDecl {
    pub name: String,
    pub params: Vec<String>,
    pub body: Block,
}

#[derive(Debug, Clone)]
pub struct Block {
    pub statements: Vec<Stmt>,
}

#[derive(Debug, Clone)]
pub enum Stmt {
    Let {
        name: String,
        value: Expr,
    },
    ExprStmt(Expr),
    Return(Expr),
    If {
        condition: Expr,
        then_block: Block,
        else_block: Option<Block>,
    },
    Assign {
        name: String,
        value: Expr,
    },
    While {
        condition: Expr,
        body: Block,
    },

}

#[derive(Debug, Clone)]
pub enum Expr {
    Call {
        name: String,
        args: Vec<Expr>,
    },
    Binary {
        left: Box<Expr>,
        op: BinOp,
        right: Box<Expr>,
    },
    IntLiteral(i64),
    VarRef(String),
    StringLiteral(String),
}



#[derive(Debug, Clone)]
pub enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Greater,
    Less,
    Equal,
}

interpreter.rs:
use std::collections::HashMap;
use crate::ast::*;

type Env = HashMap<String, Value>;

#[derive(Debug, Clone)]
pub enum Value {
    Int(i64),
    Str(String),
    Void,
}

#[derive(Debug)]
enum Control {
    None,
    Break,
    Continue,
    Return(Value),
}

pub struct Interpreter {
    functions: HashMap<String, FunctionDecl>,
    loop_depth: usize,
}

impl Interpreter {
    pub fn new(program: &Program) -> Self {
        let mut functions = HashMap::new();
        for f in &program.functions {
            functions.insert(f.name.clone(), f.clone());
        }

        Interpreter {
            functions,
            loop_depth: 0,
        }
    }

    pub fn run(&mut self) {
        let main = self.functions.get("main").expect("no main()");
        let mut env = HashMap::new();

        self.exec_block(&main.body, &mut env);
    }

    fn exec_block(&mut self, block: &Block, env: &mut Env) -> Control {
        for stmt in &block.statements {
            match self.exec_stmt(stmt, env) {
                Control::None => {}
                c => return c,
            }
        }
        Control::None
    }

    fn exec_stmt(&mut self, stmt: &Stmt, env: &mut Env) -> Control {
        match stmt {
            Stmt::Let { name, value } => {
                let v = self.eval_expr(value, env);
                env.insert(name.clone(), v);
                Control::None
            }

            Stmt::Assign { name, value } => {
                let v = self.eval_expr(value, env);
                *env.get_mut(name).expect("undefined variable") = v;
                Control::None
            }

            Stmt::ExprStmt(expr) => {
                self.eval_expr(expr, env);
                Control::None
            }

            Stmt::Return(expr) => {
                let v = self.eval_expr(expr, env);
                Control::Return(v)
            }

            Stmt::If {
                condition,
                then_block,
                else_block,
            } => {
                if self.eval_expr(condition, env).is_true() {
                    self.exec_block(then_block, env)
                } else if let Some(b) = else_block {
                    self.exec_block(b, env)
                } else {
                    Control::None
                }
            }

            Stmt::While { condition, body } => {
                self.loop_depth += 1;

                while self.eval_expr(condition, env).is_true() {
                    match self.exec_block(body, env) {
                        Control::None => {}
                        Control::Continue => continue,
                        Control::Break => break,
                        Control::Return(v) => {
                            self.loop_depth -= 1;
                            return Control::Return(v);
                        }
                    }
                }

                self.loop_depth -= 1;
                Control::None
            }

            Stmt::Break => {
                if self.loop_depth == 0 {
                    panic!("break outside loop");
                }
                Control::Break
            }

            Stmt::Continue => {
                if self.loop_depth == 0 {
                    panic!("continue outside loop");
                }
                Control::Continue
            }
        }
    }

    fn eval_expr(&mut self, expr: &Expr, env: &mut Env) -> Value {
        match expr {
            Expr::IntLiteral(i) => Value::Int(*i),
            Expr::StringLiteral(s) => Value::Str(s.clone()),

            Expr::VarRef(name) => env.get(name).unwrap().clone(),

            Expr::Binary { left, op, right } => {
                let l = self.eval_expr(left, env);
                let r = self.eval_expr(right, env);

                match (l, r, op) {
                    (Value::Int(a), Value::Int(b), BinOp::Add) => Value::Int(a + b),
                    (Value::Int(a), Value::Int(b), BinOp::Sub) => Value::Int(a - b),
                    (Value::Int(a), Value::Int(b), BinOp::Mul) => Value::Int(a * b),
                    (Value::Int(a), Value::Int(b), BinOp::Div) => Value::Int(a / b),
                    (Value::Int(a), Value::Int(b), BinOp::Greater) => Value::Int((a > b) as i64),
                    (Value::Int(a), Value::Int(b), BinOp::Less) => Value::Int((a < b) as i64),
                    (Value::Int(a), Value::Int(b), BinOp::Equal) => Value::Int((a == b) as i64),
                    _ => panic!("invalid binary op"),
                }
            }

            Expr::Call { name, args } => {
                if name == "print" {
                    let v = self.eval_expr(&args[0], env);
                    match v {
                        Value::Int(i) => println!("{}", i),
                        Value::Str(s) => println!("{}", s),
                        _ => {}
                    }
                    Value::Void
                } else {
                    let func = self.functions.get(name).unwrap();
                    let mut local = HashMap::new();

                    for (p, a) in func.params.iter().zip(args.iter()) {
                        local.insert(p.clone(), self.eval_expr(a, env));
                    }

                    match self.exec_block(&func.body, &mut local) {
                        Control::Return(v) => v,
                        _ => Value::Void,
                    }
                }
            }
        }
    }
}

impl Value {
    fn is_true(&self) -> bool {
        matches!(self, Value::Int(i) if *i != 0)
    }
}


lexer.rs:
use crate::token::Token;

pub struct Lexer {
    input: Vec<char>,
    position: usize,
}

impl Lexer {
    pub fn new(source: &str) -> Self {
        Lexer {
            input: source.chars().collect(),
            position: 0,
        }
    }

    fn current_char(&self) -> Option<char> {
        self.input.get(self.position).copied()
    }

    fn advance(&mut self) {
        self.position += 1;
    }

    fn skip_whitespace(&mut self) {
        while let Some(c) = self.current_char() {
            if c.is_whitespace() {
                self.advance();
            } else {
                break;
            }
        }
    }

    fn read_identifier(&mut self) -> String {
        let start = self.position;

        while let Some(c) = self.current_char() {
            if c.is_alphanumeric() || c == '_' {
                self.advance();
            } else {
                break;
            }
        }

        self.input[start..self.position].iter().collect()
    }

    fn read_string(&mut self) -> String {
        // Skip opening quote
        self.advance();

        let start = self.position;

        while let Some(c) = self.current_char() {
            if c == '"' {
                break;
            }
            self.advance();
        }

        let value: String = self.input[start..self.position].iter().collect();

        // Skip closing quote
        self.advance();

        value
    }

    fn read_number(&mut self) -> i64 {
        let start = self.position;

        while let Some(c) = self.current_char() {
            if c.is_ascii_digit() {
                self.advance();
            } else {
                break;
            }
        }

        let number: String = self.input[start..self.position].iter().collect();
        number.parse().unwrap()
    }


    pub fn next_token(&mut self) -> Token {
        self.skip_whitespace();

        match self.current_char() {
            Some('(') => { self.advance(); Token::LParen }
            Some(')') => { self.advance(); Token::RParen }
            Some('{') => { self.advance(); Token::LBrace }
            Some('}') => { self.advance(); Token::RBrace }
            Some(',') => { self.advance(); Token::Comma }
            Some(';') => { self.advance(); Token::Semicolon }
            Some('=') => {
                self.advance();
                if self.current_char() == Some('=') {
                    self.advance();
                    Token::EqualEqual
                } else {
                    Token::Equal
                }
            }
            

            Some('+') => { self.advance(); Token::Plus }
            Some('-') => { self.advance(); Token::Minus }
            Some('*') => { self.advance(); Token::Star }
            Some('/') => { self.advance(); Token::Slash }

            Some(c) if c.is_ascii_digit() => {
                let num = self.read_number();
                Token::Int(num)
            }


            Some('"') => {
                let s = self.read_string();
                Token::String(s)
            }

            Some(c) if c.is_alphabetic() || c == '_' => {
                let ident = self.read_identifier();
                match ident.as_str() {
                    "fn" => Token::Fn,
                    "let" => Token::Let,
                    "if" => Token::If,
                    "else" => Token::Else,
                    "for" => Token::For,
                    "return" => Token::Return,
                    "while" => Token::While,
                    "break" => Token::Break,
                    "continue" => Token::Continue,
                    _ => Token::Ident(ident),
                }
            }

            Some('>') => { self.advance(); Token::Greater }
            Some('<') => { self.advance(); Token::Less }


            None => Token::EOF,

            Some(_) => {
                self.advance();
                self.next_token()
            }
        }
    }
}

parser.rs:
use crate::ast::*;
use crate::token::Token;

pub struct Parser {
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            position: 0,
        }
    }

    fn current(&self) -> &Token {
        &self.tokens[self.position]
    }

    fn advance(&mut self) {
        self.position += 1;
    }

    fn expect(&mut self, token: Token) {
        if *self.current() == token {
            self.advance();
        } else {
            panic!("Expected {:?}, got {:?}", token, self.current());
        }
    }

    // =======================
    // PROGRAM
    // =======================

    pub fn parse_program(&mut self) -> Program {
        let mut functions = Vec::new();

        while *self.current() != Token::EOF {
            functions.push(self.parse_function());
        }

        Program { functions }
    }

    fn parse_function(&mut self) -> FunctionDecl {
        self.expect(Token::Fn);

        let name = match self.current() {
            Token::Ident(n) => {
                let n = n.clone();
                self.advance();
                n
            }
            _ => panic!("Expected function name"),
        };

        self.expect(Token::LParen);

        let mut params = Vec::new();
        while *self.current() != Token::RParen {
            if let Token::Ident(p) = self.current() {
                params.push(p.clone());
                self.advance();
                if *self.current() == Token::Comma {
                    self.advance();
                }
            } else {
                panic!("Expected parameter name");
            }
        }

        self.expect(Token::RParen);
        self.expect(Token::LBrace);

        let body = self.parse_block();

        self.expect(Token::RBrace);

        FunctionDecl { name, params, body }
    }


    fn parse_block(&mut self) -> Block {
        let mut statements = Vec::new();

        while *self.current() != Token::RBrace {
            statements.push(self.parse_statement());
        }

        Block { statements }
    }

    // =======================
    // STATEMENTS
    // =======================


    fn parse_statement(&mut self) -> Stmt {
        match self.current() {
            Token::Let => self.parse_let(),
            Token::If => self.parse_if(),
            Token::While => self.parse_while(),
            Token::Return => {
                self.advance();
                let expr = self.parse_expression();
                self.expect(Token::Semicolon);
                Stmt::Return(expr)
            }
            Token::Break => {
                self.advance();
                self.expect(Token::Semicolon);
                Stmt::Break
            }
            Token::Continue => {
                self.advance();
                self.expect(Token::Semicolon);
                Stmt::Continue
            }
            Token::Ident(_) => {
                // Lookahead for assignment
                if matches!(self.tokens[self.position + 1], Token::Equal) {
                    self.parse_assign()
                } else {
                    let expr = self.parse_expression();
                    self.expect(Token::Semicolon);
                    Stmt::ExprStmt(expr)
                }
            }
            _ => {
                let expr = self.parse_expression();
                self.expect(Token::Semicolon);
                Stmt::ExprStmt(expr)
            }

        }
    }

    fn parse_while(&mut self) -> Stmt {
        self.expect(Token::While);
        self.expect(Token::LParen);

        let condition = self.parse_expression();

        self.expect(Token::RParen);
        self.expect(Token::LBrace);

        let body = self.parse_block();

        self.expect(Token::RBrace);

        Stmt::While { condition, body }
    }


    fn parse_assign(&mut self) -> Stmt {
        let name = if let Token::Ident(n) = self.current() {
            let n = n.clone();
            self.advance();
            n
        } else {
            panic!("Expected variable name");
        };

        self.expect(Token::Equal);

        let value = self.parse_expression();
        self.expect(Token::Semicolon);

        Stmt::Assign { name, value }
    }


    fn parse_if(&mut self) -> Stmt {
        self.expect(Token::If);
        self.expect(Token::LParen);

        let condition = self.parse_expression();

        self.expect(Token::RParen);
        self.expect(Token::LBrace);

        let then_block = self.parse_block();

        self.expect(Token::RBrace);

        let else_block = if *self.current() == Token::Else {
            self.advance();
            self.expect(Token::LBrace);
            let block = self.parse_block();
            self.expect(Token::RBrace);
            Some(block)
        } else {
            None
        };

        Stmt::If {
            condition,
            then_block,
            else_block,
        }
    }



    fn parse_let(&mut self) -> Stmt {
        self.expect(Token::Let);

        let name = if let Token::Ident(n) = self.current() {
            let n = n.clone();
            self.advance();
            n
        } else {
            panic!("Expected variable name");
        };

        self.expect(Token::Equal);

        let value = self.parse_expression();

        self.expect(Token::Semicolon);

        Stmt::Let { name, value }
    }

    // =======================
    // EXPRESSIONS (PRECEDENCE)
    // =======================

    fn parse_expression(&mut self) -> Expr {
        self.parse_comparison()
    }

    fn parse_comparison(&mut self) -> Expr {
        let mut expr = self.parse_add_sub();

        loop {
            match self.current() {
                Token::Greater => {
                    self.advance();
                    let right = self.parse_add_sub();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Greater,
                        right: Box::new(right),
                    };
                }
                Token::Less => {
                    self.advance();
                    let right = self.parse_add_sub();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Less,
                        right: Box::new(right),
                    };
                }
                Token::EqualEqual => {
                    self.advance();
                    let right = self.parse_add_sub();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Equal,
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }

        expr
    }


    // + -
    fn parse_add_sub(&mut self) -> Expr {
        let mut expr = self.parse_mul_div();

        loop {
            match self.current() {
                Token::Plus => {
                    self.advance();
                    let right = self.parse_mul_div();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Add,
                        right: Box::new(right),
                    };
                }
                Token::Minus => {
                    self.advance();
                    let right = self.parse_mul_div();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Sub,
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }

        expr
    }

    // * /
    fn parse_mul_div(&mut self) -> Expr {
        let mut expr = self.parse_primary();

        loop {
            match self.current() {
                Token::Star => {
                    self.advance();
                    let right = self.parse_primary();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Mul,
                        right: Box::new(right),
                    };
                }
                Token::Slash => {
                    self.advance();
                    let right = self.parse_primary();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Div,
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }

        expr
    }

    // literals, identifiers, calls, parentheses
    fn parse_primary(&mut self) -> Expr {
        match self.current() {
            Token::Int(value) => {
                let v = *value;
                self.advance();
                Expr::IntLiteral(v)
            }

            Token::Ident(name) => {
                let name = name.clone();
                self.advance();

                // function call
                if *self.current() == Token::LParen {
                    self.advance();

                    let mut args = Vec::new();
                    while *self.current() != Token::RParen {
                        args.push(self.parse_expression());
                        if *self.current() == Token::Comma {
                            self.advance();
                        }
                    }

                    self.expect(Token::RParen);
                    Expr::Call { name, args }
                } else {
                    Expr::VarRef(name)
                }
            }

            Token::LParen => {
                self.advance();
                let expr = self.parse_expression();
                self.expect(Token::RParen);
                expr
            }

            Token::String(value) => {
                let v = value.clone();
                self.advance();
                Expr::StringLiteral(v)
            }

            _ => panic!("Unexpected token {:?}", self.current()),
        }
    }
}

semantic.rs:
use std::collections::HashMap;
use crate::ast::*;

pub struct SemanticAnalyzer {
    functions: HashMap<String, FunctionDecl>,
    scopes: Vec<HashMap<String, ()>>,
    in_loop: bool,
}

impl SemanticAnalyzer {
    pub fn new() -> Self {
        SemanticAnalyzer {
            functions: HashMap::new(),
            scopes: Vec::new(),
            in_loop: false,
        }
    }

    pub fn analyze(&mut self, program: &Program) {
        self.collect_functions(program);

        for func in &program.functions {
            self.check_function(func);
        }
    }

    fn collect_functions(&mut self, program: &Program) {
        for func in &program.functions {
            if self.functions.contains_key(&func.name) {
                panic!("Semantic error: duplicate function `{}`", func.name);
            }
            self.functions.insert(func.name.clone(), func.clone());
        }
    }

    /* ======================
        SCOPE MANAGEMENT
    ====================== */

    fn push_scope(&mut self) {
        self.scopes.push(HashMap::new());
    }

    fn pop_scope(&mut self) {
        self.scopes.pop();
    }

    fn declare_var(&mut self, name: &str) {
        self.scopes
            .last_mut()
            .unwrap()
            .insert(name.to_string(), ());
    }

    fn is_var_defined(&self, name: &str) -> bool {
        for scope in self.scopes.iter().rev() {
            if scope.contains_key(name) {
                return true;
            }
        }
        false
    }

    /* ======================
        FUNCTION CHECK
    ====================== */

    fn check_function(&mut self, func: &FunctionDecl) {
        self.push_scope();

        // Parameters are local variables
        for param in &func.params {
            self.declare_var(param);
        }

        self.check_block(&func.body);

        self.pop_scope();
    }

    /* ======================
        BLOCK / STATEMENTS
    ====================== */

    fn check_block(&mut self, block: &Block) {
        self.push_scope();

        for stmt in &block.statements {
            self.check_stmt(stmt);
        }

        self.pop_scope();
    }

    fn check_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let { name, value } => {
                self.check_expr(value);
                self.declare_var(name);
            }

            Stmt::Assign { name, value } => {
                if !self.is_var_defined(name) {
                    panic!("Semantic error: assigning to undefined variable `{}`", name);
                }
                self.check_expr(value);
            }

            Stmt::Return(expr) => {
                self.check_expr(expr);
            }

            Stmt::ExprStmt(expr) => {
                self.check_expr(expr);
            }

            Stmt::If {
                condition,
                then_block,
                else_block,
            } => {
                self.check_expr(condition);
                self.check_block(then_block);
                if let Some(b) = else_block {
                    self.check_block(b);
                }
            }

            Stmt::While { condition, body } => {
                self.check_expr(condition);
                self.check_block(body);
                let old = self.in_loop;
                self.in_loop = true;
                self.check_block(body);
                self.in_loop = old;
            }
            Stmt::Break | Stmt::Continue => {
                if !self.in_loop {
                    panic!("break/continue used outside loop");
                }
            }

        }
    }

    /* ======================
        EXPRESSIONS
    ====================== */

    fn check_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::VarRef(name) => {
                if !self.is_var_defined(name) {
                    panic!("Semantic error: undefined variable `{}`", name);
                }
            }

            Expr::Call { name, args } => {
                if name != "print" && !self.functions.contains_key(name) {
                    panic!("Semantic error: undefined function `{}`", name);
                }
                for arg in args {
                    self.check_expr(arg);
                }
            }

            Expr::Binary { left, right, .. } => {
                self.check_expr(left);
                self.check_expr(right);
            }

            Expr::IntLiteral(_) | Expr::StringLiteral(_) => {}
        }
    }
}


token.rs:
#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    // Keywords
    Fn,
    Let,
    If,
    Else,
    For,
    Return,
    While,

    // Identifiers & literals
    Ident(String),
    Int(i64),
    String(String),

    // Symbols
    LParen,   // (
    RParen,   // )
    LBrace,   // {
    RBrace,   // }
    Comma,    // ,
    Semicolon,// ;
    Equal, // =
    
    // Comparison Ops T-T
    Greater,   // >
    Less,      // <
    EqualEqual,// ==



    // Operators
    Plus,     // +
    Minus,    // -
    Star,     // *
    Slash,    // /

    // Special
    EOF,
}



Bro this is the code above:

and readme.md file:
# Nexo Programming Language

Nexo is a modern, high-performance programming language designed to combine the power of systems languages like C++ with a cleaner and more readable syntax.

## Goals

The goal of Nexo is to be:

- Fast to compile
- Native-performance
- Easy to read and write
- Built from scratch

## Example

```nexo
fn main() {
    print("Hello, Nexo!");
}
```

## Planned Features

- Native Windows binaries
- Static typing with inference
- Simple and expressive syntax
- No garbage collector
- Fast compiler
- Clean error messages

## Project Structure

```
nexo-lang/
├── compiler/     # Nexo compiler source
├── std/          # Standard library
├── examples/     # Sample Nexo programs
└── docs/         # Language documentation
```

## Roadmap

- Project initialization
- Lexer
- Parser
- Semantic analysis
- Code generation
- Standard library
- Linter
- Package manager (future)

## Contributing

Nexo is in early development. Contributions, ideas, and feedback are welcome.




Bro we need to make the code working again, it isn't working while i started implementing break and continue, in loop.
it stopped working, and bro what to do.

Bro we have to make this language working and a good language like python c etc.. a real working language.
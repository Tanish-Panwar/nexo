fn main() {
    let x = 5 + 3 * 2;
    print(x);
}


bytecode.rs:
#[derive(Debug, Clone)]
pub enum Instruction {
    PushInt(i64),
    PushString(String),
    LoadVar(String),
    StoreVar(String),

    Add,
    Sub,
    Mul,
    Div,

    Less,
    Equal,
    Greater,

    Call(String, usize),
    Return,

    Print,

    Jump(usize),
    JumpIfFalse(usize),

    Halt,
}

#[derive(Debug)]
pub struct Function {
    pub name: String,
    pub arity: usize,
    pub entry: usize, // instruction index
}

pub struct Program {
    pub functions: Vec<Function>,
    pub code: Vec<Instruction>,
}

compiler.rs:
use crate::ast::{
    Program as AstProgram,
    FunctionDecl,
    Block,
    Stmt,
    Expr,
    BinOp,
};

use super::bytecode::{
    Instruction,
    Program as BytecodeProgram,
    Function as BytecodeFunction,
};

pub struct BytecodeCompiler {
    code: Vec<Instruction>,
    functions: Vec<BytecodeFunction>,
    loop_stack: Vec<LoopContext>,
}

struct LoopContext {
    start: usize,
    breaks: Vec<usize>,
}

impl BytecodeCompiler {
    pub fn new() -> Self {
        Self {
            code: vec![],
            functions: vec![],
            loop_stack: vec![],
        }
    }

    /// ENTRY POINT
    pub fn compile(mut self, program: &AstProgram) -> BytecodeProgram {
        for func in &program.functions {
            let entry = self.code.len();
            self.compile_function(func);

            self.functions.push(BytecodeFunction {
                name: func.name.clone(),
                arity: func.params.len(),
                entry,
            });
        }

        // entry = call main
        self.code.push(Instruction::Call("main".into(), 0));
        self.code.push(Instruction::Halt);

        BytecodeProgram {
            functions: self.functions,
            code: self.code,
        }
    }

    fn compile_function(&mut self, func: &FunctionDecl) {
        // ðŸ”¥ bind parameters (reverse order)
        for param in func.params.iter().rev() {
            self.code.push(Instruction::StoreVar(param.clone()));
        }

        self.compile_block(&func.body);
        self.code.push(Instruction::PushVoid);
        self.code.push(Instruction::Return);
    }

    fn compile_block(&mut self, block: &Block) {
        for stmt in &block.statements {
            self.compile_stmt(stmt);
        }
    }

    fn compile_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let { name, value }
            | Stmt::Assign { name, value } => {
                self.compile_expr(value);
                self.code.push(Instruction::StoreVar(name.clone()));
            }

            Stmt::ExprStmt(expr) => {
                self.compile_expr(expr);
                self.code.push(Instruction::Pop);
            }


            Stmt::Return(expr) => {
                self.compile_expr(expr);
                self.code.push(Instruction::Return);
            }

            Stmt::If {
                condition,
                then_block,
                else_block,
            } => {
                self.compile_expr(condition);
                let jmp_false = self.code.len();
                self.code.push(Instruction::JumpIfFalse(0));

                self.compile_block(then_block);

                let jmp_end = self.code.len();
                self.code.push(Instruction::Jump(0));

                let else_start = self.code.len();
                if let Some(b) = else_block {
                    self.compile_block(b);
                }

                let end = self.code.len();
                self.code[jmp_false] = Instruction::JumpIfFalse(else_start);
                self.code[jmp_end] = Instruction::Jump(end);
            }

            Stmt::While { condition, body } => {
                let start = self.code.len();

                self.compile_expr(condition);
                let exit = self.code.len();
                self.code.push(Instruction::JumpIfFalse(0));

                self.loop_stack.push(LoopContext {
                    start,
                    breaks: vec![],
                });

                self.compile_block(body);
                self.code.push(Instruction::Jump(start));

                let end = self.code.len();
                self.code[exit] = Instruction::JumpIfFalse(end);

                let ctx = self.loop_stack.pop().unwrap();
                for b in ctx.breaks {
                    self.code[b] = Instruction::Jump(end);
                }
            }

            Stmt::Break => {
                let ctx = self.loop_stack
                    .last_mut()
                    .expect("break outside loop");

                let pos = self.code.len();
                self.code.push(Instruction::Jump(0));
                ctx.breaks.push(pos);
            }

            Stmt::Continue => {
                let ctx = self.loop_stack
                    .last()
                    .expect("continue outside loop");

                self.code.push(Instruction::Jump(ctx.start));
            }
        }
    }

    fn compile_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::IntLiteral(v) => {
                self.code.push(Instruction::PushInt(*v));
            }

            Expr::StringLiteral(s) => {
                self.code.push(Instruction::PushString(s.clone()));
            }

            Expr::VarRef(name) => {
                self.code.push(Instruction::LoadVar(name.clone()));
            }

            Expr::Binary { left, op, right } => {
                self.compile_expr(left);
                self.compile_expr(right);

                self.code.push(match op {
                    BinOp::Add => Instruction::Add,
                    BinOp::Sub => Instruction::Sub,
                    BinOp::Mul => Instruction::Mul,
                    BinOp::Div => Instruction::Div,
                    BinOp::Less => Instruction::Less,
                    BinOp::Greater => Instruction::Greater,
                    BinOp::Equal => Instruction::Equal,
                });
            }

            Expr::Call { name, args } => {
                for arg in args {
                    self.compile_expr(arg);
                }

                if name == "print" {
                    self.code.push(Instruction::Print);
                } else {
                    self.code.push(Instruction::Call(name.clone(), args.len()));
                }
            }
        }
    }
}


mod.rs:
mod bytecode;
mod compiler;
mod value;
mod vm;

pub use compiler::*;
pub use vm::*;

value.rs:
#[derive(Debug, Clone)]
pub enum Value {
    Int(i64),
    String(String),
    Void,
}

impl Value {
    pub fn is_truthy(&self) -> bool {
        match self {
            Value::Int(v) => *v != 0,
            _ => false,
        }
    }
}


vm.rs:
use std::collections::HashMap;

use super::bytecode::{Instruction, Program};
use super::value::Value;

#[derive(Debug)]
struct CallFrame {
    return_ip: usize,
    base: usize,
    locals: HashMap<String, Value>,
}

pub struct VM {
    ip: usize,
    stack: Vec<Value>,
    globals: HashMap<String, Value>,
    frames: Vec<CallFrame>,
    functions: HashMap<String, (usize, usize)>, // name -> (entry, arity)
    code: Vec<Instruction>,
}

impl VM {
    pub fn new(program: Program) -> Self {
        let mut functions = HashMap::new();
        for f in program.functions {
            functions.insert(f.name, (f.entry, f.arity));
        }

        let entry_ip = program.code.len() - 2; // Call main

        VM {
            ip: entry_ip,
            stack: vec![],
            globals: HashMap::new(),
            frames: vec![],
            functions,
            code: program.code,
        }
    }

    fn current_frame_mut(&mut self) -> Option<&mut CallFrame> {
        self.frames.last_mut()
    }

    fn current_frame(&self) -> Option<&CallFrame> {
        self.frames.last()
    }

    pub fn run(&mut self) {
        loop {
            match self.code[self.ip].clone() {
                Instruction::PushInt(v) => {
                    self.stack.push(Value::Int(v));
                }

                Instruction::PushString(s) => {
                    self.stack.push(Value::String(s));
                }

                Instruction::LoadVar(name) => {
                    // 1ï¸âƒ£ check local scope
                    if let Some(frame) = self.current_frame() {
                        if let Some(v) = frame.locals.get(&name) {
                            self.stack.push(v.clone());
                            self.ip += 1;
                            continue;
                        }
                    }

                    // 2ï¸âƒ£ fallback to globals
                    let v = self.globals
                        .get(&name)
                        .cloned()
                        .unwrap_or_else(|| panic!("undefined variable '{}'", name));

                    self.stack.push(v);
                }

                Instruction::StoreVar(name) => {
                    let v = self.stack.pop().unwrap();

                    if let Some(frame) = self.current_frame_mut() {
                        frame.locals.insert(name, v);
                    } else {
                        self.globals.insert(name, v);
                    }
                }

                Instruction::Add => binop(&mut self.stack, |a, b| a + b),
                Instruction::Sub => binop(&mut self.stack, |a, b| a - b),
                Instruction::Mul => binop(&mut self.stack, |a, b| a * b),
                Instruction::Div => binop(&mut self.stack, |a, b| a / b),

                Instruction::Less => cmpop(&mut self.stack, |a, b| a < b),
                Instruction::Greater => cmpop(&mut self.stack, |a, b| a > b),
                Instruction::Equal => cmpop(&mut self.stack, |a, b| a == b),

                Instruction::Print => {
                    let v = self.stack.pop().unwrap();
                    println!("{:?}", v);
                    self.stack.push(Value::Void);
                }


                Instruction::Jump(pos) => {
                    self.ip = pos;
                    continue;
                }

                Instruction::Pop => {
                    self.stack.pop();
                }

                Instruction::PushVoid => {
                    self.stack.push(Value::Void);
                }

                Instruction::JumpIfFalse(pos) => {
                    let v = self.stack.pop().unwrap();
                    if !v.is_truthy() {
                        self.ip = pos;
                        continue;
                    }
                }

                Instruction::Call(name, argc) => {
                    let (entry, arity) = self.functions
                        .get(&name)
                        .unwrap_or_else(|| panic!("undefined function '{}'", name))
                        .clone();

                    if argc != arity {
                        panic!("arity mismatch in call to '{}'", name);
                    }

                    let frame = CallFrame {
                        return_ip: self.ip + 1,
                        base: self.stack.len() - argc,
                        locals: HashMap::new(),
                    };

                    self.frames.push(frame);
                    self.ip = entry;
                    continue;
                }

                Instruction::Return => {
                    let result = self.stack.pop();

                    let frame = self.frames
                        .pop()
                        .expect("return outside function");

                    self.stack.truncate(frame.base);

                    if let Some(v) = result {
                        self.stack.push(v);
                    }

                    self.ip = frame.return_ip;
                    continue;
                }

                Instruction::Halt => break,
            }

            self.ip += 1;
        }
    }
}

fn pop_int(stack: &mut Vec<Value>) -> i64 {
    match stack.pop().unwrap() {
        Value::Int(v) => v,
        _ => panic!("expected int"),
    }
}

fn binop(stack: &mut Vec<Value>, f: fn(i64, i64) -> i64) {
    let b = pop_int(stack);
    let a = pop_int(stack);
    stack.push(Value::Int(f(a, b)));
}

fn cmpop(stack: &mut Vec<Value>, f: fn(i64, i64) -> bool) {
    let b = pop_int(stack);
    let a = pop_int(stack);
    stack.push(Value::Int(f(a, b) as i64));
}


ast.rs:
#[derive(Debug, Clone)]
pub struct Program {
    pub functions: Vec<FunctionDecl>,
}

#[derive(Debug, Clone)]
pub struct FunctionDecl {
    pub name: String,
    pub params: Vec<String>,
    pub body: Block,
}

#[derive(Debug, Clone)]
pub struct Block {
    pub statements: Vec<Stmt>,
}

#[derive(Debug, Clone)]
pub enum Stmt {
    Let {
        name: String,
        value: Expr,
    },
    ExprStmt(Expr),
    Return(Expr),
    If {
        condition: Expr,
        then_block: Block,
        else_block: Option<Block>,
    },
    Assign {
        name: String,
        value: Expr,
    },
    While {
        condition: Expr,
        body: Block,
    },
    Break,
    Continue,

}

#[derive(Debug, Clone)]
pub enum Expr {
    Call {
        name: String,
        args: Vec<Expr>,
    },
    Binary {
        left: Box<Expr>,
        op: BinOp,
        right: Box<Expr>,
    },
    IntLiteral(i64),
    VarRef(String),
    StringLiteral(String),
}



#[derive(Debug, Clone)]
pub enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Greater,
    Less,
    Equal,
}


lexer.rs:
use crate::token::Token;

pub struct Lexer {
    input: Vec<char>,
    position: usize,
}

impl Lexer {
    pub fn new(source: &str) -> Self {
        Lexer {
            input: source.chars().collect(),
            position: 0,
        }
    }

    fn current_char(&self) -> Option<char> {
        self.input.get(self.position).copied()
    }

    fn advance(&mut self) {
        self.position += 1;
    }

    fn skip_whitespace(&mut self) {
        while let Some(c) = self.current_char() {
            if c.is_whitespace() {
                self.advance();
            } else {
                break;
            }
        }
    }

    fn read_identifier(&mut self) -> String {
        let start = self.position;

        while let Some(c) = self.current_char() {
            if c.is_alphanumeric() || c == '_' {
                self.advance();
            } else {
                break;
            }
        }

        self.input[start..self.position].iter().collect()
    }

    fn read_string(&mut self) -> String {
        // Skip opening quote
        self.advance();

        let start = self.position;

        while let Some(c) = self.current_char() {
            if c == '"' {
                break;
            }
            self.advance();
        }

        let value: String = self.input[start..self.position].iter().collect();

        // Skip closing quote
        self.advance();

        value
    }

    fn read_number(&mut self) -> i64 {
        let start = self.position;

        while let Some(c) = self.current_char() {
            if c.is_ascii_digit() {
                self.advance();
            } else {
                break;
            }
        }

        let number: String = self.input[start..self.position].iter().collect();
        number.parse().unwrap()
    }


    pub fn next_token(&mut self) -> Token {
        self.skip_whitespace();

        match self.current_char() {
            Some('(') => { self.advance(); Token::LParen }
            Some(')') => { self.advance(); Token::RParen }
            Some('{') => { self.advance(); Token::LBrace }
            Some('}') => { self.advance(); Token::RBrace }
            Some(',') => { self.advance(); Token::Comma }
            Some(';') => { self.advance(); Token::Semicolon }
            Some('=') => {
                self.advance();
                if self.current_char() == Some('=') {
                    self.advance();
                    Token::EqualEqual
                } else {
                    Token::Equal
                }
            }
            

            Some('+') => { self.advance(); Token::Plus }
            Some('-') => { self.advance(); Token::Minus }
            Some('*') => { self.advance(); Token::Star }
            Some('/') => { self.advance(); Token::Slash }

            Some(c) if c.is_ascii_digit() => {
                let num = self.read_number();
                Token::Int(num)
            }


            Some('"') => {
                let s = self.read_string();
                Token::String(s)
            }

            Some(c) if c.is_alphabetic() || c == '_' => {
                let ident = self.read_identifier();
                match ident.as_str() {
                    "fn" => Token::Fn,
                    "let" => Token::Let,
                    "if" => Token::If,
                    "else" => Token::Else,
                    "for" => Token::For,
                    "return" => Token::Return,
                    "while" => Token::While,
                    "break" => Token::Break,
                    "continue" => Token::Continue,
                    _ => Token::Ident(ident),
                }
            }

            Some('>') => { self.advance(); Token::Greater }
            Some('<') => { self.advance(); Token::Less }


            None => Token::EOF,

            Some(_) => {
                self.advance();
                self.next_token()
            }
        }
    }
}


main.rs:
mod token;
mod lexer;
mod ast;
mod parser;
mod semantic;
mod vm;
mod runtime_error;



use lexer::Lexer;
use parser::Parser;
use semantic::SemanticAnalyzer;
use token::Token;
use vm::{BytecodeCompiler, VM};


use std::env;
use std::fs;

fn main() {
    let filename = &env::args().collect::<Vec<_>>()[1];
    let source = fs::read_to_string(filename).unwrap();

    let mut lexer = Lexer::new(&source);
    let mut tokens = Vec::new();
    loop {
        let t = lexer.next_token();
        tokens.push(t.clone());
        if t == Token::EOF {
            break;
        }
    }

    let mut parser = Parser::new(tokens);
    let program = parser.parse_program();

    let mut semantic = SemanticAnalyzer::new();
    semantic.analyze(&program);

    // ---- VM PATH ----
    let compiler = BytecodeCompiler::new();
    let bytecode = compiler.compile(&program);
    let mut vm = VM::new(bytecode);
    vm.run();

    // ---- INTERPRETER (REFERENCE) ----
    // let mut interpreter = Interpreter::new(&program);
    // interpreter.run();
}

parser.rs:
use crate::ast::*;
use crate::token::Token;

pub struct Parser {
    tokens: Vec<Token>,
    position: usize,
}

impl Parser {
    pub fn new(tokens: Vec<Token>) -> Self {
        Parser {
            tokens,
            position: 0,
        }
    }

    fn current(&self) -> &Token {
        &self.tokens[self.position]
    }

    fn advance(&mut self) {
        self.position += 1;
    }

    fn expect(&mut self, token: Token) {
        if *self.current() == token {
            self.advance();
        } else {
            panic!("Expected {:?}, got {:?}", token, self.current());
        }
    }

    // =======================
    // PROGRAM
    // =======================

    pub fn parse_program(&mut self) -> Program {
        let mut functions = Vec::new();

        while *self.current() != Token::EOF {
            functions.push(self.parse_function());
        }

        Program { functions }
    }

    fn parse_function(&mut self) -> FunctionDecl {
        self.expect(Token::Fn);

        let name = match self.current() {
            Token::Ident(n) => {
                let n = n.clone();
                self.advance();
                n
            }
            _ => panic!("Expected function name"),
        };

        self.expect(Token::LParen);

        let mut params = Vec::new();
        while *self.current() != Token::RParen {
            if let Token::Ident(p) = self.current() {
                params.push(p.clone());
                self.advance();
                if *self.current() == Token::Comma {
                    self.advance();
                }
            } else {
                panic!("Expected parameter name");
            }
        }

        self.expect(Token::RParen);
        self.expect(Token::LBrace);

        let body = self.parse_block();

        self.expect(Token::RBrace);

        FunctionDecl { name, params, body }
    }


    fn parse_block(&mut self) -> Block {
        let mut statements = Vec::new();

        while *self.current() != Token::RBrace {
            statements.push(self.parse_statement());
        }

        Block { statements }
    }

    // =======================
    // STATEMENTS
    // =======================


    fn parse_statement(&mut self) -> Stmt {
        match self.current() {
            Token::Let => self.parse_let(),
            Token::If => self.parse_if(),
            Token::While => self.parse_while(),
            Token::Return => {
                self.advance();
                let expr = self.parse_expression();
                self.expect(Token::Semicolon);
                Stmt::Return(expr)
            }
            Token::Break => {
                self.advance();
                self.expect(Token::Semicolon);
                Stmt::Break
            }
            Token::Continue => {
                self.advance();
                self.expect(Token::Semicolon);
                Stmt::Continue
            }
            Token::Ident(_) => {
                // Lookahead for assignment
                if matches!(self.tokens[self.position + 1], Token::Equal) {
                    self.parse_assign()
                } else {
                    let expr = self.parse_expression();
                    self.expect(Token::Semicolon);
                    Stmt::ExprStmt(expr)
                }
            }
            _ => {
                let expr = self.parse_expression();
                self.expect(Token::Semicolon);
                Stmt::ExprStmt(expr)
            }

        }
    }

    fn parse_while(&mut self) -> Stmt {
        self.expect(Token::While);
        self.expect(Token::LParen);

        let condition = self.parse_expression();

        self.expect(Token::RParen);
        self.expect(Token::LBrace);

        let body = self.parse_block();

        self.expect(Token::RBrace);

        Stmt::While { condition, body }
    }


    fn parse_assign(&mut self) -> Stmt {
        let name = if let Token::Ident(n) = self.current() {
            let n = n.clone();
            self.advance();
            n
        } else {
            panic!("Expected variable name");
        };

        self.expect(Token::Equal);

        let value = self.parse_expression();
        self.expect(Token::Semicolon);

        Stmt::Assign { name, value }
    }


    fn parse_if(&mut self) -> Stmt {
        self.expect(Token::If);
        self.expect(Token::LParen);

        let condition = self.parse_expression();

        self.expect(Token::RParen);
        self.expect(Token::LBrace);

        let then_block = self.parse_block();

        self.expect(Token::RBrace);

        let else_block = if *self.current() == Token::Else {
            self.advance();
            self.expect(Token::LBrace);
            let block = self.parse_block();
            self.expect(Token::RBrace);
            Some(block)
        } else {
            None
        };

        Stmt::If {
            condition,
            then_block,
            else_block,
        }
    }



    fn parse_let(&mut self) -> Stmt {
        self.expect(Token::Let);

        let name = if let Token::Ident(n) = self.current() {
            let n = n.clone();
            self.advance();
            n
        } else {
            panic!("Expected variable name");
        };

        self.expect(Token::Equal);

        let value = self.parse_expression();

        self.expect(Token::Semicolon);

        Stmt::Let { name, value }
    }

    // =======================
    // EXPRESSIONS (PRECEDENCE)
    // =======================

    fn parse_expression(&mut self) -> Expr {
        self.parse_comparison()
    }

    fn parse_comparison(&mut self) -> Expr {
        let mut expr = self.parse_add_sub();

        loop {
            match self.current() {
                Token::Greater => {
                    self.advance();
                    let right = self.parse_add_sub();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Greater,
                        right: Box::new(right),
                    };
                }
                Token::Less => {
                    self.advance();
                    let right = self.parse_add_sub();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Less,
                        right: Box::new(right),
                    };
                }
                Token::EqualEqual => {
                    self.advance();
                    let right = self.parse_add_sub();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Equal,
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }

        expr
    }


    // + -
    fn parse_add_sub(&mut self) -> Expr {
        let mut expr = self.parse_mul_div();

        loop {
            match self.current() {
                Token::Plus => {
                    self.advance();
                    let right = self.parse_mul_div();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Add,
                        right: Box::new(right),
                    };
                }
                Token::Minus => {
                    self.advance();
                    let right = self.parse_mul_div();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Sub,
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }

        expr
    }

    // * /
    fn parse_mul_div(&mut self) -> Expr {
        let mut expr = self.parse_primary();

        loop {
            match self.current() {
                Token::Star => {
                    self.advance();
                    let right = self.parse_primary();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Mul,
                        right: Box::new(right),
                    };
                }
                Token::Slash => {
                    self.advance();
                    let right = self.parse_primary();
                    expr = Expr::Binary {
                        left: Box::new(expr),
                        op: BinOp::Div,
                        right: Box::new(right),
                    };
                }
                _ => break,
            }
        }

        expr
    }

    // literals, identifiers, calls, parentheses
    fn parse_primary(&mut self) -> Expr {
        match self.current() {
            Token::Int(value) => {
                let v = *value;
                self.advance();
                Expr::IntLiteral(v)
            }

            Token::Ident(name) => {
                let name = name.clone();
                self.advance();

                // function call
                if *self.current() == Token::LParen {
                    self.advance();

                    let mut args = Vec::new();
                    while *self.current() != Token::RParen {
                        args.push(self.parse_expression());
                        if *self.current() == Token::Comma {
                            self.advance();
                        }
                    }

                    self.expect(Token::RParen);
                    Expr::Call { name, args }
                } else {
                    Expr::VarRef(name)
                }
            }

            Token::LParen => {
                self.advance();
                let expr = self.parse_expression();
                self.expect(Token::RParen);
                expr
            }

            Token::String(value) => {
                let v = value.clone();
                self.advance();
                Expr::StringLiteral(v)
            }

            _ => panic!("Unexpected token {:?}", self.current()),
        }
    }
}

runtime_error.rs:
#[derive(Debug)]
pub struct RuntimeError {
    pub message: String,
}

impl RuntimeError {
    pub fn new(msg: &str) -> Self {
        RuntimeError {
            message: msg.to_string(),
        }
    }
}


semantic.rs:
use std::collections::HashMap;
use crate::ast::*;

pub struct SemanticAnalyzer {
    functions: HashMap<String, FunctionDecl>,
    scopes: Vec<HashMap<String, ()>>,
    in_loop: bool,
}

impl SemanticAnalyzer {
    pub fn new() -> Self {
        SemanticAnalyzer {
            functions: HashMap::new(),
            scopes: Vec::new(),
            in_loop: false,
        }
    }

    pub fn analyze(&mut self, program: &Program) {
        self.collect_functions(program);

        for func in &program.functions {
            self.check_function(func);
        }
    }

    fn collect_functions(&mut self, program: &Program) {
        for func in &program.functions {
            if self.functions.contains_key(&func.name) {
                panic!("Semantic error: duplicate function `{}`", func.name);
            }
            self.functions.insert(func.name.clone(), func.clone());
        }
    }

    /* ======================
        SCOPE MANAGEMENT
    ====================== */

    fn push_scope(&mut self) {
        self.scopes.push(HashMap::new());
    }

    fn pop_scope(&mut self) {
        self.scopes.pop();
    }

    fn declare_var(&mut self, name: &str) {
        self.scopes
            .last_mut()
            .unwrap()
            .insert(name.to_string(), ());
    }

    fn is_var_defined(&self, name: &str) -> bool {
        for scope in self.scopes.iter().rev() {
            if scope.contains_key(name) {
                return true;
            }
        }
        false
    }

    /* ======================
        FUNCTION CHECK
    ====================== */

    fn check_function(&mut self, func: &FunctionDecl) {
        self.push_scope();

        // Parameters are local variables
        for param in &func.params {
            self.declare_var(param);
        }

        self.check_block(&func.body);

        self.pop_scope();
    }

    /* ======================
        BLOCK / STATEMENTS
    ====================== */

    fn check_block(&mut self, block: &Block) {
        self.push_scope();

        for stmt in &block.statements {
            self.check_stmt(stmt);
        }

        self.pop_scope();
    }

    fn check_stmt(&mut self, stmt: &Stmt) {
        match stmt {
            Stmt::Let { name, value } => {
                self.check_expr(value);
                self.declare_var(name);
            }

            Stmt::Assign { name, value } => {
                if !self.is_var_defined(name) {
                    panic!("Semantic error: assigning to undefined variable `{}`", name);
                }
                self.check_expr(value);
            }

            Stmt::Return(expr) => {
                self.check_expr(expr);
            }

            Stmt::ExprStmt(expr) => {
                self.check_expr(expr);
            }

            Stmt::If {
                condition,
                then_block,
                else_block,
            } => {
                self.check_expr(condition);
                self.check_block(then_block);
                if let Some(b) = else_block {
                    self.check_block(b);
                }
            }

            Stmt::While { condition, body } => {
                self.check_expr(condition);

                let old = self.in_loop;
                self.in_loop = true;
                self.check_block(body);
                self.in_loop = old;
            }

            Stmt::Break | Stmt::Continue => {
                if !self.in_loop {
                    panic!("break/continue used outside loop");
                }
            }

        }
    }

    /* ======================
        EXPRESSIONS
    ====================== */

    fn check_expr(&mut self, expr: &Expr) {
        match expr {
            Expr::VarRef(name) => {
                if !self.is_var_defined(name) {
                    panic!("Semantic error: undefined variable `{}`", name);
                }
            }

            Expr::Call { name, args } => {
                if name == "print" {
                    if args.len() != 1 {
                        panic!("Semantic error: print expects 1 argument");
                    }
                } else if let Some(func) = self.functions.get(name) {
                    if args.len() != func.params.len() {
                        panic!(
                            "Semantic error: function `{}` expects {} args, got {}",
                            name,
                            func.params.len(),
                            args.len()
                        );
                    }
                } else {
                    panic!("Semantic error: undefined function `{}`", name);
                }

                for arg in args {
                    self.check_expr(arg);
                }
            }


            Expr::Binary { left, right, .. } => {
                self.check_expr(left);
                self.check_expr(right);
            }

            Expr::IntLiteral(_) | Expr::StringLiteral(_) => {}
        }
    }
}


token.rs:
#[derive(Debug, Clone, PartialEq)]
pub enum Token {
    // Keywords
    Fn,
    Let,
    If,
    Else,
    For,
    Return,
    While,
    Break, 
    Continue,

    // Identifiers & literals
    Ident(String),
    Int(i64),
    String(String),

    // Symbols
    LParen,   // (
    RParen,   // )
    LBrace,   // {
    RBrace,   // }
    Comma,    // ,
    Semicolon,// ;
    Equal, // =
    
    // Comparison Ops T-T
    Greater,   // >
    Less,      // <
    EqualEqual,// ==



    // Operators
    Plus,     // +
    Minus,    // -
    Star,     // *
    Slash,    // /

    // Special
    EOF,
}


this is all my files for the nexo language and we have to build it like a real language we have to make it a real language that works that works on its own, and can be used.
this is how I've implemented it till  here and we have to make it more and more better, on its own so its, real not a toy language.
We have to make sure it works real. and what are the next steps, we don't add new features yet, 
we simply make the existing features best and useful and without error. we have to make sure we make it better.
first make it better then only add the features, right
and also when you tell me what to do next and what to do update remove also tell me which file and what to update.

readme.md:
# Nexo Programming Language

Nexo is a modern, high-performance programming language designed to combine the power of systems languages like C++ with a cleaner and more readable syntax.

## Goals

The goal of Nexo is to be:

- Fast to compile
- Native-performance
- Easy to read and write
- Built from scratch

## Example

```nexo
fn main() {
    print("Hello, Nexo!");
}
```

## Planned Features

- Native Windows binaries
- Static typing with inference
- Simple and expressive syntax
- No garbage collector
- Fast compiler
- Clean error messages

## Project Structure

```
nexo-lang/
â”œâ”€â”€ compiler/     # Nexo compiler source
â”œâ”€â”€ std/          # Standard library
â”œâ”€â”€ examples/     # Sample Nexo programs
â””â”€â”€ docs/         # Language documentation
```

## Roadmap

- Project initialization
- Lexer
- Parser
- Semantic analysis
- Code generation
- Standard library
- Linter
- Package manager (future)

## Contributing

Nexo is in early development. Contributions, ideas, and feedback are welcome.



and also file looks like this.

nexo/compiler/src/vm/...
nexo/compiler/src/...
nexo/examples/...


